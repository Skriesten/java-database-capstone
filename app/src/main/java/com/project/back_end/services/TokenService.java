package com.project.back_end.services;

import com.project.back_end.repo.AdminRepository;
import com.project.back_end.repo.DoctorRepository;
import com.project.back_end.repo.PatientRepository;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;

import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.DependsOn;
import org.springframework.stereotype.Component;


import javax.crypto.SecretKey;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.util.Date;
import java.util.concurrent.TimeUnit;

@Component
public class TokenService {
    String email;

    private  AdminRepository adminRepository;
    private  DoctorRepository doctorRepository;
    private  PatientRepository patientRepository;
   // private  SecretKey signingKey = Keys.hmacShaKeyFor(Base64.getDecoder().decode(System.getenv("PUBLIC_KEY")));

   //@Value("${jwt.secret}")
  // @Value("${application.jwt.secret}")  // obtained from google AI
  private String jwtSecret;

    public TokenService() {
    }

    public TokenService(AdminRepository adminRepository,
                        DoctorRepository doctorRepository,
                        PatientRepository patientRepository) {
        this.adminRepository = adminRepository;
        this.doctorRepository = doctorRepository;
        this.patientRepository = patientRepository;
    }

    public TokenService(AdminRepository signingKey) {
    }

    public SecretKey getSigningKey(){
        return Keys.hmacShaKeyFor(jwtSecret.getBytes());
    }

    @DependsOn
    public JwtBuilder generateToken(String userName) throws Exception {
        Date issuedAt = new Date();
        // Set the expiration date for 7 days from now
        long expirationTimeMillis = issuedAt.getTime() + TimeUnit.DAYS.toDays(7);
        Date expiration = new Date(expirationTimeMillis);
        // Build the JWT token
        return Jwts.builder()
              .setSubject(email)
              .setIssuedAt(issuedAt)
              .setExpiration(expiration)
             .signWith(getSigningKey());
    }

    public String extractEmail(String token){
        AdminRepository signingKey = null;
        TokenService tokenservice = new TokenService(signingKey);
      String extractedEmail = tokenservice.extractEmail(token);
      return Jwts.parser()
            .build()
            .parseClaimsJws(extractedEmail)
            .getBody()
            .getSubject();
       }

    public  boolean validateToken(String token, String role){
       String tokenRole = role; // =  extractEmail(token);
        if(tokenRole.equalsIgnoreCase(role) && role.equalsIgnoreCase("admin")){
                return true;
            }else if(tokenRole.equalsIgnoreCase(role) && role.equalsIgnoreCase("doctor")){
                return true;
            } else if(tokenRole.equalsIgnoreCase(role) && role.equalsIgnoreCase("patient")){
                return true;
            } else {
                return false;
            }
    }
}
/*  ****  INSTRUCTIONS ************************************    
 1. **@Component Annotation**
 The @Component annotation marks this class as a Spring component, meaning Spring will manage it as a bean within its application context.
 This allows the class to be injected into other Spring-managed components (like services or controllers) where it's needed.

 2. **Constructor Injection for Dependencies**
 The constructor injects dependencies for `AdminRepository`, `DoctorRepository`, and `PatientRepository`,
 allowing the service to interact with the database and validate users based on their role (admin, doctor, or patient).
 Constructor injection ensures that the class is initialized with all required dependencies, promoting immutability and making the class testable.

 3. **getSigningKey Method**
 This method retrieves the HMAC SHA key used to sign JWT tokens.
 It uses the `jwt.secret` value, which is provided from an external source (like application properties).
 The `Keys.hmacShaKeyFor()` method converts the secret key string into a valid `SecretKey` for signing and verification of JWTs.

 4. **generateToken Method**
 This method generates a JWT token for a user based on their email.
 - The `subject` of the token is set to the user's email, which is used as an identifier.
 - The `issuedAt` is set to the current date and time.
 - The `expiration` is set to 7 days from the issue date, ensuring the token expires after one week.
 - The token is signed using the signing key generated by `getSigningKey()`, making it secure and tamper-proof.
 The method returns the JWT token as a string.

 5. **extractEmail Method**
 This method extracts the user's email (subject) from the provided JWT token.
 - The token is first verified using the signing key to ensure it hasnâ€™t been tampered with.
 - After verification, the token is parsed, and the subject (which represents the email) is extracted.
 This method allows the application to retrieve the user's identity (email) from the token for further use.

 6. **validateToken Method**
 This method validates whether a provided JWT token is valid for a specific user role (admin, doctor, or patient).
 - It first extracts the email from the token using the `extractEmail()` method.
 - Depending on the role (`admin`, `doctor`, or `patient`), it checks the corresponding repository (AdminRepository, DoctorRepository, or PatientRepository)
   to see if a user with the extracted email exists.
 - If a match is found for the specified user role, it returns true, indicating the token is valid.
 - If the role or user does not exist, it returns false, indicating the token is invalid.
 - The method gracefully handles any errors by returning false if the token is invalid or an exception occurs.
 This ensures secure access control based on the user's role and their existence in the system.
*/


